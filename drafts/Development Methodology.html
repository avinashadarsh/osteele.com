<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title></title>
    
  </head>
  <body>
    <div>
      <h2>Keeping an Empty Head</h2>
      <p>GTD for proramming. &#xA0;Keep your head empty. &#xA0;Whenever anything comes to mind, put it down somewhere &#x2013; in a comment, in a todo list, or in the code itself.</p>
      <h2>Programming from the middle</h2>
      <p>Start at the level of the user story. &#xA0;Create enough architecture to implement that story. &#xA0;(This is bottom-up.) &#xA0;Assume you have the primitives that make the implementation of the user story fit in your head; and then </p>
      <p>The key to getting in the flow of programming is to minimize swapping. &#xA0;Never working on a problem that&#x2019;s bigger than your head. &#xA0;(Your head is virtual. &#xA0;You can buy a little bit of head-room with notes and whiteboards.) &#xA0;If you feel like you can&#x2019;t keep track of everything, you&#x2019;re trying to do too much; figure out how to take a smaller bite. &#xA0;Tunnel vision is your friend. &#xA0;Learn to refactor overly specific solution into more general solutions; this is more important than learning how to design overly general solutions initially. &#xA0;(It&#x2019;s refactoring at the archtiecture level.) &#xA0;Serialize the problem so that you&#x2019;re only working on one layer at a time.</p>
      <h2>Fail-fast development</h2>
      <p>Assume that every change introduces an error. &#xA0;If you&#x2019;ve added a line of code, no matter how simple, it won&#x2019;t work. &#xA0;This goes beyond test-driven development: if you wait until you&#x2019;ve implemented ten lines of code to satisfy a test case it&#x2019;s too late &#x2013; now youve got to find ten bugs in ten lines of code, which is combinatorially harder than finding one bug in one line of code.</p>
      <p>Assume that you&#x2019;ll need to run your program several times to find each bug. &#xA0;This means that you need to automate the process of telling you whether there&#x2019;s a bug. &#xA0;This is one reason that I don&#x2019;t use source level debuggers any more: if I have to interact with the program to get a trace of its state, I want to automate this instead.</p>
      <p>Don&#x2019;t write a longer expression when you can test a short one. &#xA0;Print the result of a subexpression, and work your way up. &#xA0;This optimizes for the case where you made a mistake; if you never make mistakes, it&#x2019;s a waste of time. &#xA0;Consider a to be the cost of subincremental development relative to whole shebang, and p to be the proportion of your functions that fail.</p>
      <p>This is like TDD except that (1) the grain size is smaller, and (2) you don&#x2019;t need to save the tests; so that (3) you don&#x2019;t need as much test infrastructure. &#xA0;For example, you can do this without JUnit etc., but you may need mocks and stubs. &#xA0;You need infrastructure to get to the point of your program, but you don&#x2019;t need infrastructre to extract the information from just that point. &#xA0;For example [insert example], we&#x2019;re going to record the value of x t line 1, but once we&#x2019;ve done that we&#x2019;ll move past it. &#xA0;This isn&#x2019;t a test that gets used in refactoring. &#xA0;The point is to make it so cheap to test that you do it all the time.</p>
      <h2>Humane Programming</h2>
      <p>Wil Shipley, refactoring tools, humane interfaces</p>
      <h2>How to be a Great Hacker</h2>
      <p>Love programming. &#xA0;If there&#x2019;s something else you&#x2019;d rather do, do that. &#xA0;(Site: lifestyle, commitment, maintenance: obie fernandez.)</p>
      <p>David Temkin&#x2019;s rule of thumb forinterviewing rogrammers is to ask what you&#x2019;ve written in your spare time. &#xA0;If you don&#x2019;t program as a hobby, you&#x2019;re not committed. &#xA0;The best people in every field seem to love doing it. &#xA0;There are just too many barriers to becoming truly great at something to succeed at it if you&#x2019;re not driven to spend all your time and energy on it. &#xA0;(You can become great at two things if you can find a connection between them. &#xA0;Programming is good for that because it&#x2019;s the mastery of representations and abstraction, which are generally applicable.)</p>
      <p>Follow your bliss. &#xA0;If your bliss is playing video games, you may be out of luck.</p>
      <p>Read code.</p>
      <p>Expand your boundaries.</p>
      <p>Find mentors. &#xA0;When I started programming I was largely self-taught. &#xA0;At Apple, I learned how to program from Cary Clark and David Moon, and how to manage from Ike Nassi. &#xA0;Ten years ago I learned a lot about project management from Steve McConnell. &#xA0;Five years ago I learned from Wadler, Peyton Jones. &#xA0;More recently I&#x2019;ve been learning from Mauricio Fernandez and http://sigfpe.blogspot.com. &#xA0;None of these latter folk have heard of me.</p>
      <p>Figure out how things relate. &#xA0;Being a father and husband takes a lot of my time.</p>
      <p>Craft: don&#x2019;t optimize. </p>
      <h2>Tortoise and Hare Development</h2>
      <p>I used to have two developers working for me. &#xA0;One was slow and methodical; the other couldn&#x2019;t be systematic to save his life but could make anything work. &#xA0;I used Achilles as the trailblazer, and the tortoise to build the road.</p>
      <p>Everyone has a setting for how much to discount the future. &#xA0;Becoming a great hacker is learning how to set that setting, and learning to recognize which contexts call for which setting.</p>
      <h2>Advice to a Young Programmer</h2>
      <p>Learn some styles. OOP, AOP, MOP, pure-functional. &#xA0;Learn to write code that is: short, self-documenting, extensible, efficient, readable, quick-to-write, easy-to-maintain.</p>
      <p>Write a lot of throw-away code. &#xA0;It's the only way you'll have a chance to try out different ways of programming.</p>
      <p>Write some non-throwaway code. There's nothing like maintaining a piece of code ten years after you wrote it to to teach you how to make the code that you're writing now maintainable ten years from now. &#xA0;(Write code as if you were going to be maintaining it ten years ago.)</p>
      <p>Write code that you can hand off.</p>
      <p>Investigate alternatives. &#xA0;At Apple Computer, I worked with a user interface designer named Paige Parsons. &#xA0;When I asked her to design something, she brought me three or four rough sketches, and when I picked one, she created four more from that. &#xA0;(This is standard practice for design, but it was most programmers, including me, hadn't worked with designers then.) &#xA0;These days, when I have a question about how to implement something, I write down as much as I can about how each implementation would look before I decide on one.</p>
      <p>Love programming.</p>
      <p>Read good code. &#xA0;Try to write code in the style of code that you admire.</p>
      <p>Fix it even if it's not broken it. &#xA0;Don't stop once you get it working.</p>
      <p>Work on side projects.</p>
      <p>Be fearless. &#xA0;Use source control so that you aren't afraid to try out risky ideas.</p>
      <p>Push the envelope. &#xA0;Spend some time outside your comfort zone.</p>
      <p>Know thyself. &#xA0;Learn to attend to your mental state so that you can save the hard parts for when you're smarter.</p>
      <p>Find mentors. &#xA0;Seek out people smarter than you.</p>
      <p>Know your tools.</p>
      <p>Read books.</p>
    </div>
  </body>
</html>
