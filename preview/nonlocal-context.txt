h2. Barriers

Often it's necessary to pass information from the head of a call chain to the tail without adding parameters to everything in the middle.  %(todo)Need a name for this here% There's a set of stock solutions that each have their uses and pitfalls.  These solutions rely on language-specific idioms involving closures, encapsulation, global variables.

Recent revisions to Haskell and XSLT add features to address this specific problem with syntax and semantics that are specific to this problem alone. **Also mention css**

There is an interesting symmetry between 

h3. Barriers and Tunnelling

An example is the Python program below, where the @n@ parameter is _bound_ in the implementation of @f()@, but is _accessed_ within the implementation of @h()@.

_Simple example of nonlocal context_

<pre>
def f(n):
  return g()
def g():
  return h()
def h():
  // The following line won't work:
  // n is meant to refer to the value in f()
  return n
</pre>

!/images/context-sequence/barrier-1.png!

In this program, @n@ is the <dfn>chain parameter</dfn>.  @f()@ is the parameter <dfn>supplier</dfn>, @h()@ is the <dfn>consumer</dfn>, and @g()@ is the <dfn>barrier</dfn>.  The sequence of calls from the supplier to the consumer --- @f()@ -> @g()@ -> @h()@ --- is @n@'s <dfn>chain</dfn>.

Why not pass the chain parameter as a function parameter?  (In the case of the example above, this would mean adding @n@ as a parameter to @g()@ and @h()@?)  That works in the toy program above, but not in general.  One condition has to be true for the parameter passing solution to work at all, and two other factors must hold for it to be maintainable:
# The _source_ to the functions in the barrier must be under your control.
# The _length_ of the chain from the provider must be small.
# The _number_ of chains 

Let's look at what happens when each of these conditions fails.

h3. Third-party Barrier

<pre>
def f(n, list):
  return map(h, list)
def h(x):
  // n is meant to refer to the value in f()
  return n+x
</pre>

Don't want to rewrite map.

Could use a closure, in language which support this.

<pre>
def f(n, list):
  def h(x):
    return n+x
  return map(h, list)
</pre>

Could also use a bound method, in languages which support this.

<pre>
class closure:
  def __init__(self, n):
    self.n = n
  def apply(self, x):
    return x + self.n
def f(n, list):
  return map(closure(n).apply, list)
</pre>

In languages without closures _or_ bound methods (such as C++, Java, and JavaScript), need to rewrite the _reimplement_ the @map()@ function to take an instance that implements an interface.  Fortunately, if you're working in C++ or Java, there's already an implementation of @map()@ that works this way.  Unfortunately if, if the barrier is some _other_ library (such as a SAX parser, that you're providing the content handler for), then you **etc.**

The other solutions below work for this case.

**Pull this out into a separate solution: encapsulation**

h3. Long Chain

Even if you've got control over the barrier, it can be impractical to add a parameter to all the intermediate functions in the chain.

!/images/context-sequence/barrier-2.png!

h3. Multiple Chains

Consider following table of provider/consumer relations:

|_Provider|_Consumer|
|<code>f()</code>|<code>h()</code>|
|<code>f'()</code>|<code>h'()</code>|
|<code>f''()</code>|<code>h''()</code>|

!/images/context-sequence/barrier-3.png!

h3. Refactoring

Refactoring --- works when o~n~ are the the same

h3. Global variables

pain when multithreaded
* Dynamic binding
* Fluid-let

h4. Language support
* Haskell: implicit
* XSLT 2.0: parameter tunnelling
* CSS: "descendant" selection

h2. Outtakes

The problem is how to pass information from one context to another across an intermediate context, which I will a <dfn>barrier</dfn>.

The traditional solutions are to use global or thread-local variables, often with the aid of special binding forms.  Newer solutions are to add language-level support for what Haskell calls <dfn>implicit parameters</dfn>, and what XSLT 2.0 calls <dfn>parameter tunnelling</dfn>.

h2. Todo
* Aspects
* context object
* AOP solution
* symmetry with exception handling (in intro?)
* restarts

* title
** Long-distance dependencies
** Barriers
** Non-local Context
