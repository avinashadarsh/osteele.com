h2. Client-Server MVC

bq. The Model-View-Controller (MVC) architecture is a standard architecture for interactive applications.  In client-server programming, the MVC components are distributed across at least two nodes of a network.  This leads to a set of choices about where to deploy each component of the architecture.  One solution is the traditional server-based MVC model.  Another is the Rich Internet Application (RIA) model.  In a real-world application with client-side validation, these are more similar than they might seem.

h3. Desktop MVC

In an interactive application such as Microsoft Word, there is a domain model --- the document, and representations of objects such as paragraphs, spans, and styles --- code to present the model to the user, and code to act upon the model in response to the user manipulation of input devices such as the keyboard and mouse.

Smalltalk-80 introduced the <dfn>Model-View-Controller (MVC)</dfn> architecture for structuring this type of application.  This architecture separates the maintainance of the domain model (the Model), the _presentation_ of the model (the View), and the interpretation of user actions (the Controller).

_Model-View-Controller Control Flow[2]_
!/images/web-mvc/mvc.png!

Together with the <dfn>User</dfn>, the components of an MVC architecture form two cycles of data and control flow:

# The <dfn>View Cycle</dfn>: User -> Controller -> View -> User.  The Controller responds to a user action (clicking on a scroll bar) by invoking a method on the View (@view1.scrollDown()@).  The View updates its state (it adjusts the value of @view1.xoffset@), and updates the information that it presents the user (calls @bitblt@ on @view1@'s screen area, and invokes the @draw()@ methods of views that intersect the accumulated damage region).
# The <dfn>Model Cycle</dfn>: User -> Controller -> Model -> View -> User.  The Controller handles a user action When the user deletes an entry from a list of contacts, the Controller updates the state of the Model, the view updates to match the model, and the user is presented with the updated view.  For example, when the user selects the @Delete@ item from a menu, code in the Controller might invoke @view.deleteRow()@, which invokes @view.currentSelection.delete()@, where @view.currentSelection@ is a Model object and @view.currentSelection.delete()@ is a Model method.  The @delete()@ method changes the Model data, which notifies these objects' <dfn>Listeners</dfn>, say by invoking their @registerChange()@ methods.  The set of Listeners includes View objects, which respond to the invocation by updating the display.

In a desktop application, the Model, View, and Controller run on the machine that the user interacts with.  This kind of application is easy to write (or, as easy as the domain model allows); it easily takes advantage of client platform features such as dialog boxes, offline storage, and drag and drop; and it's responsive.  The disadvantages of this architecture are the disadvantages of desktop applications in general: they are difficult to deploy, they tend to be platform-dependent, and they are generally limited to manipulating data on the local file system[3].

h3. Web Application Programming

In a web application, the server software runs on a <dfn>server</dfn>, and the user interacts with browser software running on a <dfn>client</dfn>.  The Model's data is stored on the server. The user interacts with software running on the client.

Client-server programming is difficult because the program is distributed across more than one network node.  Code has to run on the client to interact with the user.  Other code has to run on the server to interact with the data store.

In the case of a web application, the code that runs on the client includes the user agent, or <dfn>browser</dfn>.  The distributed nature of a web application creates two challenges.  One is that the application has to render data from the _server_ into a context where it can be displayed on the _client_.  The other is that information about user events has to get back from the client to the server.

The architectural decision about client-server MVC is which components to deploy to which nodes, and how to manage the communcation between them.  Should the View and the Controller run on the server or the client?  What about the Model?

!/images/web-mvc/mvc-split.png!

There's a variety of ways to make these decisions.  One solution is server-side MVC.  Another is the Rich Internet Application architecture.  But all the solutions have some elements in comment, because of the following ground rules:
# At least part of the Model has to run on the server.  This is because the Model is responsible for maintaining the integrity of the business objects, and has to be immune from client spoofing.  It's also easier to maintain integrity with code that runs on the server, although in a clustered server environment this doesn't come for free.
# The user has to be able to see the information presented by the View.  This means the View, no matter where it runs, has to ultimately control the display of this information on the client.
# The Controller has to be able to receive events that represent user activity.

h3. Server-Side MVC

In Server-Side MVC, the Model, View, and Controller run on the server.  The View generates a _representation_ of a _presentation_.  This representation is downloaded to the client, which displays it.  User interactions with the client are sent back to the server, where they generally result in the generation a new presentation, which is downloaded in turn, and _updates_ the previous presentation.  This is the <dfn>view update</dfn> operation.

_Server-Side MVC_
!/images/web-mvc/mvc-server.png!

In a Server-Side MVC <em>web</em> application, the View generates an HTML page, which is sent to the client as an HTTP response.  The browser, on the client, encodes user events as the URL, query, and POST parameters in an HTTP request.  The Controller, on the server, interprets this information as Model or View changes, and routes the request to the View, which responds with another HTML page.  The _view update_ operation in a web application is implemented as wholescale replacement of the preview view (page) by the new page.  In a browser, this is the page refresh.

In the Java community, "MVC" _means_ "Server-Side MVC".  In this context, (Server-Side) MVC is also called Model 2.  (Model 1 was a server-side application without the architecture.)  JSP, Struts, and PHP are all specific technologies that can be used to implement server-side MVC.

The advantage of Server-Side MVC for the developer is that if the Model (aka business logic) is running on the server _anyway_, this architecture allows the developer to use the same language, libraries, and data structures to write the rest of the application, and local procedure calls to communicate between components.

The disadvantage is that the quality of the user experience is limited by three factors:
# View updates in Server-Side MVC are more coarse-grained than they are in a desktop application.  A server-side MVC application can't generally update just part of a view (or an interior node in in a view hierarchy); it has to create an entirely new view and replace the old view by the new one, even when the new view is almost identical to the old one[10].  The user experience correlate of this limitation is the ubiquitous full-page refresh in server-side MVC applications.
# User events in server-side MVC are more coarse-grained than they are in a desktop application.  Multiple client-side user events, such as a series of clicks and keystrokes, are aggregated into a single HTTP request that summarizes their effect.  This has implications for the kind of feedback that the Controller is able to give; it's is why direct manipulation such as drag and drop is impossible in this architecture, and why client validation is difficult.
# The previous two problems are the special cases of the problem that the _bandwidth_ of communication between the user and the application is low.  The _latency_ of communication is also high, compared to desktop interactivy --- any Model cycle, or View cycle that involves a page refresh, is an expensive and offputting activity.

Server-Side MVC is the path of least resistance towards developing an application that provides access to an existing Model implementation.  It allows the incremental expenditure of developer resources towards a limited degreee of user interactivity.  Often only limited interactivy is required, especially for non-consumer web applications --- both the users and the organizaton would rather have developer resources go towards back-end improvements and new business features, if these resources are coming out of the same pool that improvements to the user experience would come from.

h3. Server-Side MVC: Under the Hood

Let's look again at how the user interacts with a Server-Side MVC application.  The View in a Server-Side MVC application isn't actually displaying information on the user's screen or to the user's screen reader; it's creating data which will instruct the user's <em>browser</em> to display this information.  The Client isn't reading the state of the input devices; the browser is reading this state summarizing into HTTP requests.

The diagram above hid this complexity by conflating the _User_ and the _User Agent_, and placing them both inside the computer.  (That's why the User was inside the computer in the _Server-Side MVC_ diagram.)  But the user doesn't interact directly with the HTTP and HTML protocols.  There's actually an additional piece of software --- the browser --- mediating the interaction of the user with the server component of the application.  The browser has its own Model, View, and Controller.  The browser's Model is the HTML page.  The View renders the page to the screen or screen reader, and the Controller interprets the keyboard and mouse events against the input focus state and the position of rendered elements (such as links and form elements) within the browser window.

_Server-Side MVC unpacked (slightly)_
!/images/web-mvc/mvc-vc.png!

This is still (a variant of) an MVC architecture, it's just that the View and Controller are each split between the client and the server.  The high-overhead HTTP request/response transactions occur within components: the back-end View communicates via HTML to the front-end View, and the front-end Controller communicates via HTTP to the back-end Controller.

!/images/web-mvc/mvc-vc-expanded.png!

h3. Cycle Time

There's an additional complication, which is that now there are _two_ View cycles.  User actions that don't involve a page refresh, such as scrolling the page or choosing a new form element, initiate a <dfn>Client View Cycle</dfn>.  Actions that require a page refresh, such as paging to the next ten items in a list, or searching for products that contain the term "AAC", initiate a <dfn>Server View Cycle</dfn>.  Neither of these actions changes the Model --- they're both View cycles, not Model cycles --- but they require different _kinds_ of changes to the View.

Cycles that cross the client-server boundary --- the Model Cycle, and the Server View Cycle --- are more expensive than cycles that are encompassed within a single node.

h3. The Client Thickens

The final step in fleshing out the diagram above is to account for input validation, such as checking that a credit card number has the right syntax or that input field co-occurrence restrictions (_if_ menu item 1 is selected, _then_ input field 2 must be non-empty).  Given the expense of a View Cycle that involves the server, it's desirable to do as much input validation on the client as possible, to avoid the page refresh.  Since the input is validated against the model schema, this requires downloading a little bit of business logic to the client.

It may be 

_Server-Side MVC unpacked_
!/images/web-mvc/mvc-mvc.png!

We could draw this as a special case of single-Model MVC, just like we did when only the View and the Controller were split between the server and the client. The Model in this interpretation contains multiple components: a server-side component which runs on the server, and at least one client-side library which the View links into the HTML page that it downloads to the client.

This _isn't_ a thick client, or a Rich Internet Application.  The only code running on the client is the browser, and whatever the current page includes.  This is still the world of Server-Side MVC, as produced by JSP or Struts or what have you, generating HTML+JavaScript.  All that's changed is that the architecture diagram now reflects (more of) the software's full complexity.

That complexity includes such research topics code generation for multiple targets (IE Mac, IE Windows, Netscape, Mozilla, Safari, Opera), process migration, and (usually manual) CPS conversion to maintain program state across pages.  No wonder web programming is difficult!

h3. RIA Architecture

!/images/web-mvc/mvc-client-2.png!

!/images/web-mvc/mvc-client.png!

h3. Conclusion

I first thought I'd find this.  This makes the RIA look more complicated than Server-Side MVC, because

|Server-Side MVC|RIA|
|<img src="/images/web-mvc/mvc-server-small.png"/>|<img src="/images/web-mvc/m-vc-small.png"/>|

(Conflates the User and the User Agent.  It doesn't take into account interactions between the User and the User Agent, but takes them as a monolithic whole.  This makes the architecture simpler, at the expense of the user experience design.)

But instead I found this:

|Server-Side MVC|RIA|
|<img src="/images/web-mvc/mvc-mvc-small.png"/>|<img src="/images/web-mvc/m-mvc-small.png"/>|

This makes the RIA architecture look _simpler_ than Server-Side MVC, because it's only got one view.

Lets return to earth from architecture astronaut land.  The RIA architecture may look simpler on paper, but it can still be a more complicated deployment story.  It's only simpler overall if there's a significant amount of client-side programming _anyway_.

h4. Notes

fn1. There's a middle ground between changing the Model and changing the View, where the user _previews_ a set of changes, in a dialog box or a multipage web form, before _committing_ them with an @Okay@ button or @Order@ button.  This is where Undo and the Back button break down.  However, the distinction is generally clear enough to organize an architecture around.


fn2. This may not be you father's MVC.  Sometimes the User is omitted from the diagram.  (The user is integral to the control flow, but isn't part of the _software_ architecture, after all.)  Sometimes the arrow from Controller to View is missing. (Presumably you can't page or scroll in these applications, or else the state of the presentation is considered part of the Model.)  Sometimes there are extra control flow or dependency arrows; and sometimes there are extra components, representing the Store that backs the Model, or who knows what else.  But none of this variation makes a difference to what I want to talk about in this post, which is what happens when there's at least a Model, and Controller, a View, and a client and a server.

"_Google for MVC_":http://images.google.com/images?q=model+view+controller
!/images/web-mvc/mvc-sampler.png (MVC Sampler)!

fn3. Just because the Model runs on the user's desktop machine, doesn't mean that the Model's Store is the local file system.  That's just the path of least resistance, and the typical use case for a desktop application.  Putting the store somewhere else is an uphill battle for a desktop application, but comes for free with a web application.  Conversely, supporting interactivity (e.g. responsive feedback, direct manipulation) is an uphill battle for a server-application, and comes easily with a desktop application.



h2. Outtakes


Actually, server rendering generally has _two_ Views and Controllers.  There's code running on the client too.  (In a web application, it's HTML, JavaScript, and maybe some ActiveX.)  The server MVC generates a page that contains another MVC, which is downloaded to the client.  The Model of the client MVC is the HTML DOM.  The View is the CSS flow that the browser renders from this DOM.  The Controller is the set of user interface controls that the _browser_ presents.  Some of the events that the user creates using these controls affect the browser view (scrolling, resizing), others are tunnelled to the _server_ controller as HTTP requests.  Some of _these_ events affect the _server_ View, resulting in the creation of another _client_ MVC which is downloaded to the client.  Finally, some bubble all the way back to the Model --- where they typically result in new client MVC downloads too.

Note that none of this has anything to do with RIAs --- this is how PHP, JSP, and other server-side pages rendering work.  And no _wonder_ web application programming is difficult --- it's really program generation for heterogenous targets (IE Mac, IE Windows, and Netscape, say), with some other research topics such as process migration and CPS conversion thrown in.

h4. Long Distance

In architectural terms, components of the MVC are distributed across two nodes of a network, and must communicate via a network protocol[4].  This makes writing them difficult, because network protocols are both harder to use and less efficient than local protocols.  Network protcols are harder to use with because they require more information to set up, they have more failure modes, and they are typically either asynchronous, or require multithreading to avoid locking the GUI(Graphical User Interface).  They are less efficient because they have higher latency and lower throughput than local protocols.  These difficulties makes it hard to design effective user experiences for them.  Distributing components across computing nodes therefore both increases the difficulty of coordinating information between them, and decreases the responsiveness of operations that involve such coordination.

These components of the architecture communicate using procedure calls or parameterized messages, or by changing objects that are shared between the components.

Information from the user is generally in the form of <dfn>user events</dfn> --- objects or messages which represent manipulations of an input device such as a mouse a keyboard.  User events result either in changes to the Model, or changes to the View[1].  Changes to the Model include model changes such as adding an item to a shopping cart, or submitting an order. Changes to the View include presentation changes such as paging or scrolling through a list of data, filtering search results, opening a property inspector or a details view, or otherwise disclosing additional information about the Model data that the View presents.


The View and the Controller _both_ handle user interaction.  They collectively correspond to the Presentation layer of a "three-tier architecture":http://en.wikipedia.org/wiki/3_tier.  (The Presentation layer is also called the  User Interface or Client, and each of the other tiers has other names as well.)

!/images/web-mvc/3-tier-mvc.png!


In a client-server application, the _Model_ has to run on a server, and the _User_ has to interact with a client.  The issue therefore isn't _whether_ to distribute the components across nodes, but _how_: which components run on which nodes?  Specifically, where do the View and Controller run?  Like every interesting question in software engineering, there's not a right answer to this, but there is a set of tradeoffs involved in making one choice versus the other.  These tradeoffs involve development time, cost, and risk; client and server resource utilization; code and logic duplication (especially of domain model or business logic); and the quality of the application's user experience.

In the rest of this post, I want to explore two answers to the question of how to distribute the components.  In <dfn>Server-Side MVC</dfn>, the View and the Controller run on the _server_, making the initial implementation easier, if the user experience demands are not too great.  In a <dfn>Rich Internet Application</dfn> (RIA), the View and the Controller run on the _client_.  When I first started working on RIAs, I thought that these were radically different architectures, because they assign the View and the Controller to different nodes, which resulted in all sorts of trickle-down effects; and that the RIA architecture was more complicated.  Now I believe that although the _technologies_ used to create these applications may be different, the _architectures_, once they're elaborated to account for consumer features such as client validation, end up being very similar.

h3. Two Styles
* From the Model _outwards_.
* From the User _inwards_.

Model-Outwards

start with business logic, and expose it
business logic and code that manages access to the database or other store).  

User-Inwards

User Experience, or Design.

h2. Model Exposure

The View contains a collection of <dfn>cursors</dfn>.  A cursor is a reference to set of entities in the Model.  A cursor has a <dfn>position</dfn> (which entities it is pointing to), and a <dfn>detail level</dfn> (how much information it is displaying about these entities).  Position might also be called <dfn>selection</dfn>; detail level might also be called <dfn>depth</dfn>, although it's not linear.  In SQL, the position corresponds to the WHERE, and the detail level corresponds to the SELECT.

Illustration: tree, with the left or right child circled to show position and the node itself or some of its children circled to show detail level.

A cursor also has a <dfn>filter</dfn>.  A filter defines the set of displayed children.  The filter is similar to the detail level, except that the filter specifies the homogenous content of the view, such as which of its children are displayed, and the detail level specifies its heterogenous content, such as which properties.  (These should be unified.)  Todo: discrete versus continuous selection; different kinds of filtering --- spatial versus semantic versus arbitrary; characteristic function.  Compositing filters.  A filter might be just a set of filters.

Predicate-based versus reference-based cursors.

The state of the View is a set of cursors.  Changes to the view involve changes o the <em>set</em> of cursors; changes to the selection; and changes to the <em>properties<em> of each cursor: the position, detail level, and filter.  (Should spatial positioning be called out separately?)  The set of cursors in the View state is the <dfn>scope</dfn> of the view; the current selection is the <dfn>focus</dfn>.

User-initiated changes to the Model are mediated by the View selection.  They involve adding, deleting, updating, or moving entities, and adding, deleting, or changing the values of properties.

h3. More outtakes

Another possiblity is that the Model runs on the server, and the View and Controller run on the client.  Examples: applications that collaborate with a central data store.  *Model* is different from *data*.  Can be web, or desktop application with central store or file server.

Note the invariants: a user action that affects the model *always* requires a server round-trip to display the result.  (But see "Caching the Model", below.)  And client-side validation *always* requires a duplication of business logic between the client and the server: the validation must be present on the server because (1) race conditions are resolved on the server, and (2) you can't trust the client anyway.  And it must be present on the client because server validation is too slow: it's generally not acceptable to wait until the Submit button is pressed to generate a page that says the credit card number didn't have enough digits or that the password field was left blank.

Here's what's different between the architectures:
* Whether changes to the Model require a _full-page refresh_, or refresh part of the page.  In the static
* Whether changes to the _View_ require a server round-trip too.
* Whether code threads user interface state, or just model state.  Model state has to be threaded anyway, because it's committed to the model.

h3. Caching the Model

preflighting changes
client-side validation is an example of this

 --- and, out of all the logically possible answers, I'd like to focus on three that are in popular use: server-side page rendering; server-side rendering with client-side validation; and client applications (or Rich Internet Applications).

_Note that the Model could be on yet another node_

h3. Topics
* Trade-offs
* Exposing Application State
* REST

To do:
* add tracebacks from bookmark bar


h3. Undo, Back, and the Web

Web Undo

One of the innovations of the Macintosh was to rationalize "undo" as a checkpoint

h2. To do
* running examples
* extract "Slicing MVC": three tiers, latency, how many request/responses go acrosss different kinds of cycles; three kinds of cycles
* review
* trackbacks

Conventional server-side MVC treats the Browser and the User as synonymous; this is the other reason it's associated with a mediocre user experience, because the architecture is simply not set up to model the grain of user interaction at less than the web page level.

fn4. RPC(Remote Procedure Call) or RMI(Remote Method Invocation), network-distributed objects, or implementations of these facilities on top of other other protocols such as HTTP.

I want to show how these architectures are more similar to each other, once you fill in the details, than they might at first appear -- in particular, how even Server-Side MVC requires a secondary MVC on the client, making it similar in practice to a mini-RIA.

fn10. Frames work around problem if the page layout is a sufficiently rectangular, but come with a variety of other constraints.