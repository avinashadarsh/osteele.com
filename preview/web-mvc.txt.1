h2. Client-Server MVC

bq. The Model-View-Controller (MVC) architecture is a standard architecture for interactive applications.  In client-server programming, the MVC components are distributed across at least two nodes of a network.  This leads to a set of choices about where to deploy each component of the architecture.  One solution is the traditional server-based MVC model.  Another is the Rich Internet Application (RIA) model.  In a real-world application with client-side validation, these are more similar than they might seem.

Smalltalk-80 introduced the <dfn>Model-View-Controller (MVC) architecture</dfn>.  This architecture separates the _maintainance_ of the domain model, the _presentation_ of the model, and the _interpretation_ of user actions.  Each of these roles corresponds to a component of the MVC architecture.  The <dfn>Model</dfn> maintains the domain model; the <dfn>View</dfn> presents the model state to the user; and the <dfn>Controller</dfn> interprets information from the user.

Information from the user is generally in the form of <dfn>user events</dfn> --- objects or messages which represent manipulations of an input device such as a mouse a keyboard.  User events result either in changes to the Model, or changes to the View[1].  Changes to the Model include model changes such as adding an item to a shopping cart, or submitting an order. Changes to the View include presentation changes such as paging or scrolling through a list of data, filtering search results, opening a property inspector or a details view, or otherwise disclosing additional information about the Model data that the View presents.

The components of an MVC architecture form a cycle that includes the <dfn>User</dfn>.  The View displays the Model data to the User.  The User initiates events that the Controller interprets, and which result in changes to either the Model or the View, which is re-displayed to the user.  User-initiated changes to the state of the Model, such as updating a phone number, result in a flow of information from User -> Controller -> Model -> View -> User, where in the last stage the presentation reflects the fact that the change has been committed to the model.  User-initiated changes to the state of the View, such as searching for contacts that begin with "S", result in a flow of information from User -> Controller -> View -> User.

_Model-View-Controller Control Flow[2]_
!/images/web-mvc/mvc.png!

The View and the Controller _both_ handle user interaction.  They collectively correspond to the Presentation layer of a "three-tier architecture":http://en.wikipedia.org/wiki/3_tier.  (The Presentation layer is also called the  User Interface or Client, and each of the other tiers has other names as well.)

!/images/web-mvc/3-tier-mvc.png!

h3. Desktop MVC

In a desktop application such as Word or Excel, the entire application runs on a single computer.  The components of the architecture communicate using procedure calls or parameterized messages, or by changing objects that are shared between the components.  For instance, when the user selects the @Delete@ item from a menu, code in the Controller might invoke @view.deleteRow()@, which invokes @view.currentSelection.delete()@, where @view.currentSelection@ is a Model object and @view.currentSelection.delete()@ is a Model method.  The @delete()@ method changes the Model data, which notifies these objects' <dfn>Listeners</dfn>, say by invoking their @registerChange()@ methods.  The set of Listeners includes View objects, which respond to the invocation by updating the display.

This is the architecture of a classic non-networked application.  This kind of application is easy to write (or, as easy as the domain model allows); it easily takes advantage of client platform features such as dialog boxes, offline storage, and drag and drop; and it's responsive.  The disadvantages of this architecture are the disadvantages of desktop applications in general: they are difficult to deploy, they tend to be platform-dependent, and they are generally limited to manipulating data on the local file system[3].

h3. Web Application Programming

In a web application, the server software runs on a <dfn>server</dfn>, and the user interacts with browser software running on a <dfn>client</dfn>.  The Model's data is stored on the server. The user interacts with software running on the client.

The distributed nature of a web application creates two challenges.  One is that the application has to render data from the _server_ into a context where it can be displayed on the _client_.  The other is that user events have to get from the client to the server.

The architectural decision about client-server MVC is which components to deploy to which nodes.  Should the View and the Controller run on the server or the client?  What about the Model?

Ground rules:
* At least part of the Model has to run on the server.
* The user has to be able to see the information presented by the View.
* The Controller has to be able to receive events generated by the user.

!/images/web-mvc/mvc-split.png!

h3. Server-Side MVC

In Server-Side MVC, the Model, View, and Controller all run on the server.  The View generates a _representation_ of a _presentation_.  This representation is downloaded to the client, which displays it.  User interactions with the client are sent back to the server, where they generally result in the generation a new presentation, which is downloaded in turn, and _updates_ the previous presentation.  This is the <dfn>view update</dfn> operation.

!/images/web-mvc/mvc-server.png!

In a Server-Side MVC <em>web</em> application, the View generates an HTML page, which is sent to the client as an HTTP response.  The browser, on the client, encodes user events as the URL, query, and POST parameters in an HTTP request.  The Controller, on the server, interprets this information as Model or View changes, and routes the request to the View, which responds with another HTML page.  The _view update_ operation in a web application is implemented as wholescale replacement of the preview view (page) by the new page.  In a browser, this is the page refresh.

In the Java community, "MVC" _means_ "Server-Side MVC".  In this context, (Server-Side) MVC is also called Model 2.  (Model 1 was a server-side application without the architecture.)  JSP, Struts, and PHP are all specific technologies that can be used to implement server-side MVC.

The advantage of Server-Side MVC for the developer is that if the Model (aka business logic) is running on the server _anyway_, this architecture allows the developer to use the same language, libraries, and data structures to write the rest of the application, and local procedure calls to communicate between components.

The disadvantage is that the quality of the user experience is limited by three factors:
# Every view _update_ is a view _replacement_.
# The _bandwidth_ of communication between the user and the application is very low.  The application doesn't receive information about fine-grained user activity such as mouse movements and individual clicks (unless they're on a link), and can't give domain- or context-dependent feedback about how the location of these movements lines up with the model.
# The _latency_ of communication between the user and the application is very high, at least compared to desktop interactivy.

Server-Side MVC is the path of least resistance towards developing an application that provides access to an existing Model implementation.  It allows the incremental expenditure of developer resources towards a limited degreee of user interactivity.  Often only limited interactivy is required --- both the users and the organizatons would rather have developer resources go towards back-end improvements and new business features, if these resources are coming out of the same pool that user experience improvements would come from.

h4. Long Distance

In architectural terms, components of the MVC are distributed across two nodes of a network, and must communicate via a network protocol[4].  This makes writing them difficult, because network protocols are both harder to use and less efficient than local protocols.  Network protcols are harder to use with because they require more information to set up, they have more failure modes, and they are typically either asynchronous, or require multithreading to avoid locking the GUI(Graphical User Interface).  They are less efficient because they have higher latency and lower throughput than local protocols.  These difficulties makes it hard to design effective user experiences for them.  Distributing components across computing nodes therefore both increases the difficulty of coordinating information between them, and decreases the responsiveness of operations that involve such coordination.

h4. ...and client-side too?

Let's look again at how the user interacts with a Server-Side MVC application.  The View in a Server-Side MVC application isn't actually displaying information on the user's screen (or to the user's screen reader); it's creating data which will instruct the user's <em>browser</em> to display this information.  The user isn't generating events for the Client; the user is generating events that the browser interprets and summarizes into HTTP requests.  The user is interacting with the server View and Controller at a remove, not just in network distance (and latency), but also in granularity.  This distance has three consequences:

# View updates in Server-Side MVC are more coarse-grained than in a desktop application.  In both server-side and desktop MVC, View states are hierarchical.  However, a server-side MVC application can't generally update just part of a view; it has to create an entirely new view and replace the old view by the new one.  (The user experience correlate of this limitation is the ubiquitous full-page refresh in server-side MVC applications, even when the new page is almost identical to the old one.)
# User events in server-side MVC are much more coarse-grained than the corresponding notions in desktop MVC.  The Controller is actually receiving relatively course-grained events, when the user selects a link or presses a button, that aggregate whole sets of user actions such as entering data into a set of input fields.  This has implications for the kind of feedback that the Controller is able to give; this is why direct manipulation such as drag and drop is impossible in this architecture, and why client validation is difficult.
# There's actually an additional piece of software --- the browser --- mediating the interaction of the user with the server component of the application.  The browser has its own Model, View, and Controller.  The browser's Model is the HTML page.

!/images/web-mvc/mvc-vc.png!
!/images/web-mvc/mvc-vc-expanded.png!
!/images/web-mvc/mvc-mvc.png!

Actually, server rendering generally has _two_ Views and Controllers.  There's code running on the client too.  (In a web application, it's HTML, JavaScript, and maybe some ActiveX.)  The server MVC generates a page that contains another MVC, which is downloaded to the client.  The Model of the client MVC is the HTML DOM.  The View is the CSS flow that the browser renders from this DOM.  The Controller is the set of user interface controls that the _browser_ presents.  Some of the events that the user creates using these controls affect the browser view (scrolling, resizing), others are tunnelled to the _server_ controller as HTTP requests.  Some of _these_ events affect the _server_ View, resulting in the creation of another _client_ MVC which is downloaded to the client.  Finally, some bubble all the way back to the Model --- where they typically result in new client MVC downloads too.

Note that none of this has anything to do with RIAs --- this is how PHP, JSP, and other server-side pages rendering work.  And no _wonder_ web application programming is difficult --- it's really program generation for heterogenous targets (IE Mac, IE Windows, and Netscape, say), with some other research topics such as process migration and CPS conversion thrown in.

h3. RIA

!/images/web-mvc/mvc-client.png!

h4. The Duplicated Model

!/images/web-mvc/mvc-client-2.png!

h4. Notes

fn1. There's a middle ground between changing the Model and changing the View, where the user _previews_ a set of changes, in a dialog box or a multipage web form, before _committing_ them with an @Okay@ button or @Order@ button.  This is where Undo and the Back button break down.  However, the distinction is generally clear enough to organize an architecture around.


fn2. This may not be you father's MVC.  Sometimes the User is omitted from the diagram.  (The user is integral to the control flow, but isn't part of the _software_ architecture, after all.)  Sometimes the arrow from Controller to View is missing. (Presumably you can't page or scroll in these applications, or else the state of the presentation is considered part of the Model.)  Sometimes there are extra control flow or dependency arrows; and sometimes there are extra components, representing the Store that backs the Model, or who knows what else.  But none of this variation makes a difference to what I want to talk about in this post, which is what happens when there's at least a Model, and Controller, a View, and a client and a server.

_Google for MVC_
!/preview/mvc-sampler.png (MVC Sampler)!

fn3. Just because the Model runs on the user's desktop machine, doesn't mean that the Model's Store is the local file system.  That's just the path of least resistance, and the typical use case for a desktop application.  Putting the store somewhere else is an uphill battle for a desktop application, but comes for free with a web application.  Conversely, supporting interactivity (e.g. responsive feedback, direct manipulation) is an uphill battle for a server-application, and comes easily with a desktop application.



h2. Outtakes


In a client-server application, the _Model_ has to run on a server, and the _User_ has to interact with a client.  The issue therefore isn't _whether_ to distribute the components across nodes, but _how_: which components run on which nodes?  Specifically, where do the View and Controller run?  Like every interesting question in software engineering, there's not a right answer to this, but there is a set of tradeoffs involved in making one choice versus the other.  These tradeoffs involve development time, cost, and risk; client and server resource utilization; code and logic duplication (especially of domain model or business logic); and the quality of the application's user experience.

In the rest of this post, I want to explore two answers to the question of how to distribute the components.  In <dfn>Server-Side MVC</dfn>, the View and the Controller run on the _server_, making the initial implementation easier, if the user experience demands are not too great.  In a <dfn>Rich Internet Application</dfn> (RIA), the View and the Controller run on the _client_.  When I first started working on RIAs, I thought that these were radically different architectures, because they assign the View and the Controller to different nodes, which resulted in all sorts of trickle-down effects; and that the RIA architecture was more complicated.  Now I believe that although the _technologies_ used to create these applications may be different, the _architectures_, once they're elaborated to account for consumer features such as client validation, end up being very similar.

h3. Two Styles
* From the Model _outwards_.
* From the User _inwards_.

Model-Outwards

start with business logic, and expose it
business logic and code that manages access to the database or other store).  

User-Inwards

User Experience, or Design.

h2. Model Exposure

The View contains a collection of <dfn>cursors</dfn>.  A cursor is a reference to set of entities in the Model.  A cursor has a <dfn>position</dfn> (which entities it is pointing to), and a <dfn>detail level</dfn> (how much information it is displaying about these entities).  Position might also be called <dfn>selection</dfn>; detail level might also be called <dfn>depth</dfn>, although it's not linear.  In SQL, the position corresponds to the WHERE, and the detail level corresponds to the SELECT.

Illustration: tree, with the left or right child circled to show position and the node itself or some of its children circled to show detail level.

A cursor also has a <dfn>filter</dfn>.  A filter defines the set of displayed children.  The filter is similar to the detail level, except that the filter specifies the homogenous content of the view, such as which of its children are displayed, and the detail level specifies its heterogenous content, such as which properties.  (These should be unified.)  Todo: discrete versus continuous selection; different kinds of filtering --- spatial versus semantic versus arbitrary; characteristic function.  Compositing filters.  A filter might be just a set of filters.

Predicate-based versus reference-based cursors.

The state of the View is a set of cursors.  Changes to the view involve changes o the <em>set</em> of cursors; changes to the selection; and changes to the <em>properties<em> of each cursor: the position, detail level, and filter.  (Should spatial positioning be called out separately?)  The set of cursors in the View state is the <dfn>scope</dfn> of the view; the current selection is the <dfn>focus</dfn>.

User-initiated changes to the Model are mediated by the View selection.  They involve adding, deleting, updating, or moving entities, and adding, deleting, or changing the values of properties.

h3. More outtakes

Another possiblity is that the Model runs on the server, and the View and Controller run on the client.  Examples: applications that collaborate with a central data store.  *Model* is different from *data*.  Can be web, or desktop application with central store or file server.

Note the invariants: a user action that affects the model *always* requires a server round-trip to display the result.  (But see "Caching the Model", below.)  And client-side validation *always* requires a duplication of business logic between the client and the server: the validation must be present on the server because (1) race conditions are resolved on the server, and (2) you can't trust the client anyway.  And it must be present on the client because server validation is too slow: it's generally not acceptable to wait until the Submit button is pressed to generate a page that says the credit card number didn't have enough digits or that the password field was left blank.

Here's what's different between the architectures:
* Whether changes to the Model require a _full-page refresh_, or refresh part of the page.  In the static
* Whether changes to the _View_ require a server round-trip too.
* Whether code threads user interface state, or just model state.  Model state has to be threaded anyway, because it's committed to the model.

h3. Caching the Model

preflighting changes
client-side validation is an example of this

 --- and, out of all the logically possible answers, I'd like to focus on three that are in popular use: server-side page rendering; server-side rendering with client-side validation; and client applications (or Rich Internet Applications).

_Note that the Model could be on yet another node_

h3. Topics
* Trade-offs
* Exposing Application State
* REST

To do:
* add tracebacks from bookmark bar


h3. Undo, Back, and the Web

Web Undo

One of the innovations of the Macintosh was to rationalize "undo" as a checkpoint

h2. To do
* running examples
* review
* trackbacks

Conventional server-side MVC treats the Browser and the User as synonymous; this is the other reason it's associated with a mediocre user experience, because the architecture is simply not set up to model the grain of user interaction at less than the web page level.

fn4. RPC(Remote Procedure Call) or RMI(Remote Method Invocation), network-distributed objects, or implementations of these facilities on top of other other protocols such as HTTP.

I want to show how these architectures are more similar to each other, once you fill in the details, than they might at first appear -- in particular, how even Server-Side MVC requires a secondary MVC on the client, making it similar in practice to a mini-RIA.