Item: Life Without Breakpoints

In the early '90s, I considered myself a mean C/Pascal/assembly programmer.
I had been working in Apple System Software for a couple of years on
everything from the Quickdraw GX init loading and window manager
system call patches; to the higher-level algorithms that it used for
rendering bitmaps, tiled patterns, and halftones; to program-modifying
code that inserted runtime validation instrumentation into the GX
sources.

The C and Pascal world had recently seen a revolution in debugging
tools.  Source debuggers, replete with single stepping, breakpoints,
and watchpoints, were just becoming available in the microcomputer
world.  Although I had cut my teeth on the debugging techniques that,
at best, let me poke at the stack and registers with a machine
debugger and, at worst, gave me the opportunity to poke a byte to the
screen so that I could tell what state the program had been in when it
froze the operating system, I felt that these new tools took me to
another level of productivity.

Then I moved to Apple Cambridge, and started hanging out with bunch of
Lisp programmers.

Two things surprised me about these guys.  One was that they had
missed this revolution in debugging tools that had occurred over the
past few years.  The other was that seemed to be a lot more productive
than I was.

At the time, I didn't realize that these three surprises might be
causually connected.

What did strike me was that the Lisp guys didn't seem to miss the
source debugger.  It wasn't just that didn't have source debugging ---
it was, after all, relatively new at the time, and I knew plenty of C
and Pascal programmers who lived without it --- but that their eyes
didn't mist over when they saw what was available.  "That's nice,"
they said, "but I'd rather have xxx," where xxx could be a smarter
compiler, a well-designed language feature, or a more emacs-like
editor.

I ended up hanging out at Apple Cambridge for a couple more
years. (During that time, I was even involved in the implementation of
a source debugger for a Lisp-like language, Dylan.)  At the end of
that time, I didn't exactly throw away my source stepping debugger
when I had to program in C and Pascal (which were then called Java),
but I didn't pine for them or feel like I was working with one hand
tied behind my back when I programmed in environments for which these
didn't have these tools --- environments for languages such as
Smalltalk, Python, and Haskell.

What I had learned in the meantime was how to use the Listener.

The ubiquitous feature of Lisp development environments is the Listener.  The Listener is a command-line interface for baseic shell.

There are two styles of software development: Edit/Compile/Debug
development, and REPL development.  They are different development
cycles; they arrange the activities of programming (API exploration,
program exploration, testing) into separate tasks; and they make best
use of separate development tools.

Write-first, or Edit/Compile/Debug development, breaks program
construction and debugging into two phases.  Program construction
introduces functionality and bugs; debugging removes the bugs.
Writing and testing are separate tasks.  A fast compiler may allow a
programmer to switch between them in less than a minute, but they
require at least a mental context switch, and a separate focus of
attention and set of tools.

Edit/Compile/Debug development depends on writing code, and then using
the debugger to understand (usually, to debug) the code that you've
just written.  Here, the editor is the primary tool of getting new
code (functionality and bugs) into the program, and the debugger is
the primary tool for getting the newly introduced bugs out.  ECD
development requires a good debugger, typically with source debugging,
and possibly with watchpoints.  Editor features such as intellisense
are important too.  ECD typical (although not the only possible) mode
of development with C, C++, and Java.

REPL development depends on way to evaluate and refine program
fragments within the program environment.  Scripting languages such as
Perl and Python and shell scripting languages such as csh and bash
typically have a REPL (Read-Event-Print Loop) that can be used for
this; Smalltalk and Mathematica a worksheet; and Lisp implementations
typically have both (traditionally called the Listener).
Implementations differ as to whether what is typed into the REPL is
evaluated, or compiled and executed; the effect is the same.  In REPL
development the REPL is used both for exploratory programming (to play
with and verify the functionality of an API) and to try out program
fragments.  Once these work they can be collected into program
libraries.

[REPL development isn't the same as (and predates) Test Driven
Development, although there's obviously some synergy.  In particular,
REPL development makes it easy to iteratively develop test cases
within a REPL and then migrate them to a test suite, similarly to the
way program fragments are migrated to a source library.]

DRY applied to processes
anything you do more than once is a process
processes should be saved
you'll have to do it again

new software adoption
