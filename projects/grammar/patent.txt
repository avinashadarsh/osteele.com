Title: A mechanism for using an edit history to suggest document changes

Description

This patent describes a mechanism for suggesting changes to a document based upon the edit history of the document.  When a user changes a word in a document, this mechanism suggests changes to other words, to maintain the grammaticality of the changed sentence.

Unlike mechanisms that perform a static analysis of the current state of the document, this mechanism can take account of previous edits in order to suggest subsequent changes.  For example, if the user changes "He is leaving" to "He will leaving", the system can suggest the subsequent change to "leaving" to produce "He will leave"; but if the user changes "He will leave" to "He will leaving", the system can instead suggest changing "will" to produce "He is leaving".  A mechanism that examines only the current state of the document will not be able to distinguish these cases.

Related Work

Spell checking
Grammar checking
EAGER?
[media lab]

Embodiment

Overview

The suggestion mechanism suggests edit changes to the user based on a history of user edits.  This mechanism consists of a text edit process, an observation process, edit tracking process, a suggestion generation process, and a suggestion selection process.  The user interacts with the text edit process to edit a text document.  The observation process notifies the edit tracking process when the text changes.  The edit tracking process matches text changes against a database of rules, and uses the results of these matches to update an internal table of edit states.  The suggestion generation process uses the edit states to generate a list of suggestions.  Lastly, the suggestion selection process presents these suggestions to the user, and applies selected suggestions to the text.  This set of processes runs repeatedly so long as the text is being edited.

In more detail: The text edit process presents a text document to the user, and makes changes to the document contents based upon user gestures such as keystrokes and mouse manipulations. The observation process monitors the document text and collects prior and current text states after each locally complete edit.  ("Locally complete edit" is defined below.)  The compound edit tracking process matches locally complete edits against rules (also defined below) to infer a set of compound edit states.  The suggestion generation process uses the compound edit states to generate a list of suggestions.  The suggestion selection process presents this list to the user, and applies selected suggestions to the text. 

The grammar creation mechanism creates a data structure that the suggestion mechanism can use to suggest edit changes.  It creates this data structure from a list of valid and invalid word pattern lists, from a list of compound edit patterns, or from a combination of these inputs.  This mechanism consists of a rule template expansion step, rule inference step, a rule decomposition step, a graph construction step, and a graph labelling step.  The rule template expansion step creates rules from rule templates.  The rule inference step compares pairs of valid pattern lists, and constructs compound rules that transform a word list that matches one valid pattern list to another.  The rule decomposition step creates from each compound rule a set of sequences of partial rules, that insert, modify, or delete single words in a word list.  The graph construction step uses these partial rule sequences to construct a finite state transducer (FST) that represents the sequential application of partial rules.  The graph labelling step labels the final nodes of the FST.

Data Structures

The primary data structures used in these process are as follows:

A string is a list of characters, including whitespace and paragraph separators.  (This is a standard meaning in computer science.)

A word is a structure that represents the morphological analysis of a single word.  It consists of a stem, a surface form (the word as it appears in the document), a category such as NOUN or VERB, and optional other attributes such as tense, person, and number.

A word set contains a source location, and a set of words that represent alternative morphological analyses of the token at that source location.

At several points in the processes described in this embodiment, two sets of data are compared: one that describes or is generated from the state of the document prior to the current edit, and one that describes or is generated from the current document state.  Data that is created from the prior state of the document is referred to as prior data: there is a prior text, a prior token list, and a prior list of word sets.  Data that is created from the current state of the document is referred to as current data: the current text, the current token list, and the current list of word sets.

A difference consists of an index, an action, and an optional token.  The action is INSERT, DELETE, or REPLACE.

A word pattern is a set of attributes that can be matched against a word or word set.

A state is a unique label (a string or number).  A state represents the state in a finite state automaton.  A state can be initial or non-initial, and final or non-final.  States are used to connect rules in an edit grammar (below): if a rule matches a change that results from a user gesture, the system may generate suggestions from rules whose prior states match the matching rule's post state.

A rule consists of two states --- a prior state and a post state --- and two lists of word patterns --- again, a prior pattern list and a post pattern list.

An edit grammar consists of a set of states, a set of rules, the label of the initial state, and a set of labels of final states.  The prior and post states of each rule in a grammar are members of the grammar's state set.  A grammar is therefore an instance of the computer science structure known as a Finite State Automaton [or transducer], except that the transitions have a specific structure.

[Merge above:]
A tagged word consists of a form, a stem, a tag, and an optional number, tense, and person.  The form is a normalized representation of the string representation of the word as it occurs in the text.  (It is normalized by converting it to a conventional case, spelling, and hyphenization.  For example, "He" might be converted to "he".)

An word alternative set consists of a set of tagged words that share a form.  For example, the token whose content is "proceeds" might map to an alternative set that contains the tagged word {stem: "proceed", tag: VERB, number: SINGULAR} and {stem: "proceed", tag: NOUN, number: PLURAL}.  "Fish" might map to an alternative set that contain {stem: "fish", tag: NOUN, number: SINGULAR}, {stem: "fish", tag: NOUN, number: PLURAL}, and {stem: "fish", tag: VERB, number: PLURAL}.



Text Edit Process

The text edit process presents a text document and interprets gestures that the user makes as changes to this document.  Examples of a text edit process are the programs Emacs, VIM, TextEdit on the MacOS(TM) operating system, Notepad on the Windows(TM) operating system, and Microsoft Word(TM).  The text edit process is required to notify the observation process when an edit has occurred, and to make available to the observation process the current text content of the document.

Observation Process

As the user edits the text, the system tracks the prior state of the text (prior to the latest edit) and the current state of the text.  It also maintains a snapshot of the text.  At the completion of each edit, the snapshot and the current state are submitted to the edit tracking process as the prior and current text, in order to update the list of suggestions that the suggestion selection process displays to the user.

[TBD: don't update snapshot when current edit is within the same word as the previous word.  This maintains "I see" as the prior text in the sequence of edits 0:"I see" -> 1:"I aseeing" -> 2:"I amseeing" -> 3:"I am seeing", skipping 1 and 2.]

In the preferred embodiment, each keystroke or gesture that modifies the document content is an edit, and the observation process is therefore executed after each keystroke or gesture.  It is also possible to execute these processes less frequently, such as when the computer is idle for a specified amount of time, or when the selection text edit selection cursor moves out of the most recently edited word.

In the preferred embodiment, the entire prior and current document text are submitted to the edit tracking process.  In an optimization, only a portion of the text is submitted: for example, the character span affected by the user edit plus a certain window on either side, or the sentence or paragraph affected by the user edit.

Edit Tracking Process

The Edit Tracking Process consists of a tokenization step, a token comparison step, a morphological analysis step, a rule matching step, and a state update step.

The tokenization step splits the text into a sequence of tokens.  A token is a structure composed of a string, that represents a single word or punctuation character, together with a source location and an index.  A prior token list is generated from the prior text, and a current token list is generated from the current text.

The token comparison step uses a standard difference algorithm to create a list of changes that, applied to the prior token list, create a list that is identical to the current token list.  This step then adds a 'prior' index to each token in the current token list.  A token's prior index indicates the index of the token in the prior token list that corresponds to this token.  If the token is the result of an INSERT action, it has no prior token; if a DELETE action specifies a prior token, no token in the current token list will have this token's index as its prior index.

[TBD: move the algorithm description here.]

The morphological analysis step transforms a list of tokens into a list of word sets, by transforming each token into a set of word structures.

There are a set of well-known techniques for doing this [cite Allen].

In the preferred embodiment, a lexicon and a list of inflexional rules are used.  The lexicon specifies the syntactic category (part of speech) for stems such as "dog" and "walk", as well as exceptions such as "men" (not "mans") for the plural of "man".  The rules consist of syntactic categories, string substitutions, and properties, such as as N: "#" -> "s#" {number: PLURAL} to indicate that an "s" can be appended to the end of a noun to produce a plural noun.

The rule matching step tests each rule against the word set lists that correspond to both the prior and current states of the text, to collect a set of rules whose application would transform the prior state to the current state, and positions at which these rules apply.

The state update step uses the prior state of the system, together with this set of rules, to induce a system state that reflects the history of document edits and how they correspond to actions with multiple steps.

The prior and current texts are tokenized, to produce a prior token list and a current token list.  Each token is the composition of a "content" string indicating the string content of the token, and an "index" number indicating the index of the token within the token list.  For example, the string "He leaves" would be tokenized into a list whose first element is the structure {content: "He", index: 0}, and whose second element is the structure {content: "leaves", index: 1}.

Tagging
The prior and current token lists are compared using a standard difference algorithm to produce a list of changes.  A change is a position (relative to the prior token list); an action (insert, delete, or change); and, in the case of an insert or change, the token that is inserted or changed to.

A rule consists of a prior list and current list.  Each item in these lists is a word pattern.  A word pattern, like a tagged word, contains a form, a stem, a tag, a number, and other attributes that are present in a word.  Unlike a word, all of these attributes are optional.  For example, a word template might only contain the fields {tag: VERB, tense: PRESENT}, omitting both the form and stem attributes.

The word patterns in the current list of a rule may also contain an index attribute.  If present, this index gives the position within the rule's prior list that the item in the post list corresponds to.  In this case, the post word represents a change.  If the post word does not contain an index, it represents an insertion.  It is not necessary for each word in the prior list to be matched by a word in the post list.  If no word in the post list indexes a word in the prior list, the rule represents a deletion.

A word pattern matches a word if each property that is specified in the word pattern, is present with the same value in the word.  A word pattern matches a word set if it matches any word in that alternative set.

A rule matches the prior word list at position n if the first word pattern in the rule's prior list matches the word set at position n in the prior word list; the second word pattern in the rule's prior list, if present, matches the word set at position n+1 in the prior word list; and so on.

A word pattern P in a rule's post list matches position n of the post word list if it matches the word W at position n in the post word list and, if P contains an index attribute, the difference between the P and its prior matches W's prior.  [Maybe not needed.]

If a word pattern in a rule's post list has an index n, the word pattern's "prior" is the nth word pattern in the rule's prior list.

Each token in the post token list, that does not match an insertion, has a prior token.  The prior tokens are computed as follows.  First, let n0 = n1 = 0.  "Stepping to n" defines a process where, so long as n0 < n, prior[n0] and post[n1] are marked as corresponding, and n0 and n1 are incremented by one.  For each change, in sequence, let n be the position of the change and action be its action.  If the action is INSERT, step to n-1 and then increment n1.  If the action is DELETE, step to n-1 and then increment n0.  Otherwise step to n.

The difference between a word pattern A and a word pattern B is a word pattern that contains all the properties of A except those properties that are also properties of B, and with a different value in B than in A.  For example, the difference between A={number: PLURAL, tense: PRESENT} and B={number: SINGULAR} is {tense: PRESENT}.  This means that although A 

The change list is exploded: any change with a REPLACEMENT action, and where the prior and post tokens do not have words that share a stem, is replaced by a DELETION and an INSERTION.

Alternatively, for each corresponding prior and post tag set, if the prior and post don't share a stem, the correspondence is removed.

[Extension: splice back into styled text]
[Extension; programming languages.  Can update one type or variable when others are renamed.]

Computing the initial state: For each change window (pos) and each initial rule, determine whether the rule matches at position pos-lc, where lc is the length of the left context for that rule.  The initial state set is the set of pairs (S, pos'), where S is R's post state and pos' is the post position that corresponds to the prior position pos-lc.

Updating the state: As above, but also: for each state (S, pos) and each rule whose prior state is S and that matches at pos, add (S', pos'), where S' is the rule's post state and pos' is the post position that corresponds to the prior position pos.

Suggestion Generation Process

The rule application step selects rules based on the system state, and applies them to the post text to create a set of edit suggestions.  The presentation step presents edit suggestions to the user.  The edit application step applies a selected edit to the text.

Suggestions: For each state (S, pos) in the current state such that S is a non-terminal state, and each rule R whose prior state is S, collect (R, pos') where ....   Match R against the post word list at pos' to produce an action list.

If a rule's prior list matches a word list at a position, the action list is a list of differences that represent the differences that can apply to the word list to produce a word list that matches the rule's post list.  Iterate in parallel through each word pattern in the prior and post lists.  If the next prior and post pattern correspond, then if the post pattern matches the prior word, then etc.

Suggestion Selection Process

Grammar Construction Mechanism


Example:
Pattern templates:
+ NP[#] V[#]
* NP[#] V[-#]

=> patterns
+ NP[sing] V[sing]
+ NP[pl] V[pl]
* NP[sing] V[pl]
* NP[pl] V[sing]

=> rules
(1) NP[sing] V[sing] -> NP[pl] V[pl]
(2) NP[pl] V[pl] -> NP[sing] V[sing]

=> partials
(1a) NP[sing] V[sing] -> NP[sing] V[pl]
(1b) NP[sing] V[pl] -> NP[pl] V[pl]
(1a') NP[sing] V[sing] -> NP[pl] V[sing]
(1b') NP[pl] V[sing] -> NP[pl] V[pl]

(2a) NP[pl] V[pl] -> NP[pl] V[sing]
(2b) NP[pl] V[sing] -> NP[sing] V[sing]
(2a') NP[pl] V[pl] -> NP[sing] V[pl]
(2b') NP[sing] V[pl] -> NP[sing] V[sing]

States:
(A) NP[sing] V[sing]
(B) NP[sing] V[pl]
(C) NP[pl] V[sing]
(D) NP[pl] V[pl]

FSA:
A -> *B -> D
   \> *C /

D -> *B -> A
   \> *C  /

[refinement: focus on edit window]
[refinement: use a parser instead of a tagger]