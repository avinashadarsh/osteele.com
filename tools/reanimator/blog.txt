<a style="float:right" href="/tools/rematch"><img src="/images/2006/rematch-small.png"></a>

Here's something I've wanted for a long time.  So I finally <a href="/tools/rematch">built it</a>.  "reMatch":/tools/rematch is a tool for visualizing how "regular expression":http://en.wikipedia.org/wiki/Regular_expression engines use "finite-state automata":http://en.wikipedia.org/wiki/Finite_state_automaton to match regular regular expression patterns against text.

This is intended to demonstrate the <em> implementation</em> of regular expressions.  If you want to learn <em>how to use them</em> instead, I recommend these references instead:
* "Regular-Expressions.info":http://www.regular-expressions.info/
* A.M. Kuchling's "Regular Expression HOWTO":http://www.amk.ca/python/howto/regex/
* Steve Mansour "A Tao of Regular Expressions":http://sitescooper.org/tao_regexps.html
* Jeffrey Friedl's "Mastering Regular Expressions (Amazon)":http://sitescooper.org/tao_regexps.html
* The Regular Expression Library's "list of resources":http://www.regexlib.com/Resources.aspx


h3. The User Interface

The screen has these areas:

h4. The Pattern

The "pattern" shows the regular expression.  Click on it to set another regular expression to match against.

<wp:quicktime src="http://osteele.com/images/2006/rematch/pattern.mov" width="377" height="22"/>

h4. The Input

The "input" is the string that is matched.  As you type into the input string, the color of this string indicates whether it's a complete match (green), a partial match (blue), or a non-match (red).

<wp:quicktime src="/images/2006/rematch/input.mov" width="377" height="30"/>

h4. The Graphs

There are two graphs which, which each display a <dfn>finite-state automaton</dfn> (FSA) that corresponds to the regular expression in the "pattern" area.  As you type into the "input" area, the graphs also update, to display the state of the match.

A <dfn>*deterministic FSA*</dfn> (a DFA) is like a board game, with a counter that is moved according to the successive letters of the input string.  The counter starts at the initial state (the leftmost circle with the arrow from off the board).  Each consecutive letter of the input string tells where to move the counter to next.  If the counter ends up in a terminal state (a double circle), there was a match.

<wp:quicktime src="/images/2006/rematch/dfa.mov" width="309" height="224"/>

A <dfn>*nondeterministic FSA*</dfn> is the same except that when there's more than one legal move, you take them both.

<wp:quicktime src="/images/2006/rematch/nfa.mov" width="222" height="226"/>

The nonterministic FSA bears the most direct resemblance to the regular expression.  In exchange for this simplicity in its *construction*, it's more complex to *evaluate*: instead of keeping track of just one counter, you have to keep track of a set of them.  (This is an instance of the compile-time versus execution-time trade-offs that computer science is rife with.)

If you want to learn more about finite-state automata, the "wikipedia entry":http://en.wikipedia.org/wiki/Finite_state_automaton has some useful information, but this also seems like a good place to plug my <a href="http://www.amazon.com/gp/product/oliversteele-20/0131655639/">father-in-law's book</a>.

h3. Implementation details

!/images/2006/rematch-architecture.png!

The front end is written in "OpenLaszlo":http://www.openlaszlo.org, and compiled to Flash.  It uses AJAX and JSON to request the FSAs and the graphs.

The back end is written in Python and C.  The Python part is my "PyFSA":http://osteele.com/software/python/fsa/ library, plus a bit of glue to turn various JavaScript objects and graph files into JSON strings.  There's also a cache so that my shared server doesn't get quite so stressed even if the site becomes popular.  (Having the front end logic on the client should help here too.)

The C portion is the wonderful <a href="http://http://www.graphviz.org">GraphViz</a>.  PyFSA creates a .dot file for each FSA, and uses GraphViz to lay out the graph.  The server parses the annotated .dot file into a JavaScript object, and uses JSON to download the resulting graph to the client.

An OpenLaszlo class on the client interprets the JavaScript graph description into a sequence of drawing instructions.  It also saves the node positions, so that it can animate against them.

h4. Implementation choices

<b>Client vs. server</b>: There's no reason that this couldn't be a client-side-only application.  I just happened to have PyFSA lying around, and didn't feel like porting it to JavaScript.  My goal for this was one day, and I didn't think a port of PyFSA would fit into this.  (It ended up taking three anyway, because I forgot about implementing cubic beziers and JSON, and because I got carried away and added animation.)

<b>CGI vs. FastCGI</b>: I've been doing most of my server-side programming with either PHP or FastCGI and Ruby, so that pages don't take so long to serve.  This is the first Python service I've deployed since I started using FastCGI, and I was planning to use it.  But Python doesn't include FastCGI in its library, and the fact that there were four different third-party libraries with different APIs, none of them endorsed, and that the <a href="http://www.python.org/peps/pep-0222.html">latest PEP to mention FastCGI</a> was deferred five years ago, made me unwilling to take on the project of evaluating them.  I stuck with CGI, which is in the standard library.

<b>OpenLaszlo vs. DHTML</b>: It would be just as easy to draw the graph itself using the "canvas class":http://www.whatwg.org/specs/web-apps/current-work/#scs-dynamic in DHTML.  I balked at doing the animation and user interface in DHTML, though.  (There's little touches like laying the graphs out horizontally only if there's enough room, which were only a few lines of declarative code in OpenLaszlo.)  And then it wouldn't have worked on as many browsers.  I decided to wait until <a href="http://wiki.openlaszlo.org/DHTML_Target">OpenLaszlo compiles to DHTML</a>, for a DHTML version of this. 

<b>PyFSA vs. &hellip;</b>:  There are higher-performance C implementation of FSA minimization and determinization.  I went with my own because it's the only one i know of that has the option of preserving source location information across transformations.  I use source location information minimally in the interface, and might add more.

h3. Credits

Thanks to Margaret Minsky and Gary Drescher for commenting on a draft of the application.  I used Patrick Logan's "json-py":http://sourceforge.net/projects/json-py/ for server-side JSON.  The credits for "GraphViz":http://www.graphviz.org/ are <a href="http://www.graphviz.org/Credits.php">here</a>.  Thanks to my former colleages at "Laszlo Systems, Inc.":http://openlaszlo.org for helping create the <a href="http://openlaszlo.org">OpenLaszlo</a> platform.  I adapted Philip J. Scheider's code for subdividing cubic beziers; this is a compact implementation of <a href="http://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">de Casteljau's algorithm</a> for Algol-like languages.  Thanks to Guido and company for Python.  Lastly, since people always ask, I drew the architecture diagram with "Omigraffle":http://www.omnigroup.com/applications/omnigraffle/ (gee I wish I got a commission!) --- which I like because I'm not much of a designer, and diagrams I draw with it are passable without much work.