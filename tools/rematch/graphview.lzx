<library>
  <class name="graphview" extends="drawview">
    <method name="drawGraph" args="graph"><![CDATA[
      this.graph = graph;
      this.states = [];
      var radius = 17;
      var doubleradius = 21;
      clear();
      
      // adjust the positions to accomodate the start arrow
      var x = graph.start.x - doubleradius;
      if (x < 20)
        translateGraph(graph, 20-x);
      
      // draw the edges
      beginPath();
      // arrow to the initial state
      var x = graph.start.x-1, y = graph.start.y;
      x -= node.shape=='doublecircle' ? doubleradius : radius;
      moveTo(x-15, y);
      lineTo(x-5, y);
      
      for (var i in graph.edges) {
        var e = graph.edges[i];
        var stops = e.pos;
        moveTo(e.pos[0].x, e.pos[0].y);
        for (var j = 1; j < e.pos.length; ) {
          var c1 = e.pos[j++];
          var c2 = e.pos[j++];
          var c3 = e.pos[j++];
          cubicBezierTo(c1.x, c1.y, c2.x, c2.y, c3.x, c3.y);
        }
      }
      this.lineWidth = 3;
      this.strokeStyle = 0xc0c0c0;
      stroke();
      
      // draw the arrow heads
      this.fillStyle = this.strokeStyle;
      beginPath();
      // arrow to initial state
      var x = graph.start.x-1, y = graph.start.y;
      x -= node.shape=='doublecircle' ? doubleradius : radius;
      var da = 10;
      var as = 12;
      var theta = -Math.PI;
      moveTo(x, y);
      lineTo(x-as*Math.cos(theta-da), y-as*Math.sin(theta-da*2));
      lineTo(x-as/2, y);
      lineTo(x-as*Math.cos(theta+da), y-as*Math.sin(theta+da*2));
      lineTo(x, y);
      fill();
      for (var i in graph.edges) {
        var e = graph.edges[i];
	if (e.endArrow) {
	  beginPath();
          var p0 = e.pos[e.pos.length-1];
          var p1 = e.endArrow;
          var theta = Math.atan2(p0.y-p1.y, p0.x-p1.x);
          moveTo(p1.x, p1.y);
          lineTo(p1.x-as*Math.cos(theta-da), p1.y-as*Math.sin(theta-da));
          lineTo(p1.x-as*Math.cos(theta+da), p1.y-as*Math.sin(theta+da));
          lineTo(p1.x, p1.y);
	  fill();
	}
      }
      
      // draw the nodes
      beginPath();
      for (var i in graph.nodes) {
        var node = graph.nodes[i];
        oval(node.x, node.y, radius);
        if (node.shape=='doublecircle')
          oval(node.x, node.y, doubleradius);
      }
      this.strokeStyle = 0;
      this.lineWidth = 1;
      stroke();
      
      for (var i = 0; i < this.subviews.length; i++) {
        this.subviews[i].setVisible(false);
        //this.subviews[i].destroy();
      }
      for (var i in graph.edges) {
        var e = graph.edges[i];
        if (!e.label) continue;
        if (false && i < this.subviews.length) {
          var v = this.subviews[i];
	  v.setAttribute('x', e.pos[2].x);
          v.setAttribute('y', e.pos[2].y);
	  v.setAttribute('x', e.lp.x);
          v.setAttribute('y', e.lp.y);
          v.setAttribute('label', e.label);
          v.setVisible(true);
        } else
          new LzText(this, {x: e.lp.x, y: e.lp.y-10, label: e.label});
      }
    ]]></method>
  </class>
  
  <script>
    function translateGraph(graph, dx) {
      for (var i in graph.nodes)
        graph.nodes[i].x += dx;
      for (var i in graph.edges) {
        var e = graph.edges[i];
	e.lp.x += dx;
	e.endArrow.x += dx;
	for (var j in e.pos)
	  e.pos[j].x += dx;
      }
    }
  </script>
</library>
