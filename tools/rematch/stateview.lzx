<library>
  <class name="stateview" extends="drawview"
	 width="0" height="0"
	 fgcolor="${Math.floor(this.hue)*256 + 255-Math.floor(this.hue)}"
	 >
    <attribute name="hue" value="0"/>
    <attribute name="t" value="0"/>
    <method event="oninit">
      beginPath();
      var radius = 17;
      oval(0,0,radius,radius);
      fill();
    </method>
    <method name="setState" args="s, duration"><![CDATA[
      if (arguments.length < 2) duration = 0;
      var s0 = this['state'];
      //Debug.write(this,s0,'->',s);
      this.state = s;
      this.set = duration ? this.animate : this.setAttribute;
      animateT.stop();
      if (s == null) {
        set('opacity', 0, duration);
        set('hue', 0, duration);
        return;
      }
      var n = graph.nodes[s];
      var edge = null; 
      if (duration)
        for (var i in graph.edges) {
          if (graph.edges[i].start == s0 && graph.edges[i].stop == s)
            edge = graph.edges[i];
      }   
      if (edge) {
        var path = (new Graph(graph.nodes, graph.edges)).makeEdgePath(edge);
        gPath = path;
        gNode = this;
        this.path = path;
        this.t = 0;
        animateT.duration = duration;
        animateT.doStart();
      } else {
        set('x', n.x, duration);
        set('y', n.y, duration);
      }
      set('opacity', 0.5, duration);
      set('hue', Array.includes(graph.terminalNodes, s) ? 255 : 0, duration);
   ]]></method>
    <animator name="animateT" attribute="t" to="1" start="false"/>
    <method event="ont">
      var p = path.atT(t);
      setAttribute('x', p.x);
      setAttribute('y', p.y);
    </method>
  </class>
  
  <class name="fsaStateDisplayManager">
    <!-- set: graph, model -->
    <method name="setStates" args="states">
      for (var i in subviews)
        subviews[i].setVisible(false);
      var tn = graph.nodes;
      this.stateviews = [];
      for (var i in states) {
        var s = states[i];
        var sv = new stateview(this, {});
	this.stateviews.push(sv);
        sv.graph = graph;
        sv.setState(s);
      }
      this.transitions = {}
    </method>
    <method name="advanceStates" args="symbol, duration"><![CDATA[
      if (arguments.length < 2) duration = 0;
      var transitions = model.transitions;
      // first, remove duplicate states
      for (var i = 1; i < stateviews.length; i++)
        for (var j = 0; j < i; j++)
	  if (stateviews[j] && stateviews[i].state == stateviews[j].state) {
	    stateviews[j].setVisible(false);
	    stateviews[j] = null;
	  }
      Array.compact(stateviews);
      // now, split and move the states
      var newviews = [];
      for (var i in this.stateviews) {
        var sv = this.stateviews[i];
        var s = sv.state;
        for (var j in transitions) {
          var t = transitions[j];
          if (t.start == s && t.edge.indexOf(symbol) >= 0) {
            var s1 = t.end;
            if (sv) {
              sv.setState(s1, duration);
	      sv = null;
            } else {
	      // we've already moved this state,
	      // so we need to clone it and move the copy
	      var n = graph.nodes[s];
              var svn = new stateview(this, {x: n.x, y: n.y});
              svn.graph = graph;
              newviews.push(svn);
	      svn.setState(s1, duration);
            }
          }
        }
        if (sv) sv.setState(null, duration);
      }
      this.stateviews = stateviews.concat(newviews);
    ]]></method>
  </class>
  
  <script><![CDATA[
    function Graph(nodes, edges) {
      this.nodes = nodes;
      this.edges = edges;
    };
    Graph.prototype.makeEdgePath = function (edge) {
      var path = new Path;
      var points = edge.pos;
      var n0 = this.nodes[edge.start];
      var n1 = this.nodes[edge.stop];
      path.addLine({x: n0.x, y: n0.y}, points[0]);
      for (var i = 0; i+1 < points.length; i += 3)
        path.addCubic([points[i], points[i+1], points[i+2], points[i+3]]);
      path.addLine(points[points.length-1], {x: n1.x, y: n1.y});
      return path;
    }
  ]]></script>  
</library>
