<library>
  <class name="stateview" extends="drawview"
	 width="0" height="0"
	 fgcolor="${Math.floor(this.hue)*256 + 255-Math.floor(this.hue)}"
	 >
    <attribute name="state" value="null"/>
    <attribute name="hue" value="0"/>
    <attribute name="t" value="0"/>
    
    <method event="oninit">
      beginPath();
      var radius = 17;
      oval(0,0,radius,radius);
      fill();
      this.history = [];
    </method>
    
    <method name="clone">
      var clone = new stateview(this.parent, {x: this.x, y: this.y, bgcolor: this.bgcolor});
      clone.graph = this.graph;
      clone.state = this.state;
      return clone;
    </method>
    
    <method name="setState" args="s, duration"><![CDATA[
      if (arguments.length < 2) duration = 0;
      var s0 = this['state'];
      //Debug.write(this,s0,'->',s);
      this.setAttribute('state', s);
      this.set = duration ? this.animate : this.setAttribute;
      animateT.stop();
      if (s == null) {
        set('opacity', 0, duration);
        set('hue', 0, duration);
        return;
      }
      var n = graph.nodes[s];
      var edge = null; 
      if (duration)
        edge = (new Graph(graph.nodes, graph.edges)).findEdge(s0, s);
      if (edge) {
        var path = (new Graph(graph.nodes, graph.edges)).makeEdgePath(edge);
        gPath = path;
        gNode = this;
        this.path = path;
        this.t = 0;
        animateT.duration = duration;
        animateT.doStart();
      } else {
        set('x', n.x, duration);
        set('y', n.y, duration);
      }
      set('opacity', 0.5, duration);
      set('hue', Array.includes(graph.terminalNodes, s) ? 255 : 0, duration);
   ]]></method>
    
    <animator name="animateT" attribute="t" to="1" start="false"/>
    <method event="ont">
      var p = path.atT(t);
      setAttribute('x', p.x);
      setAttribute('y', p.y);
    </method>
  </class>
  
  <!-- this is a view because the states are its children -->
  <class name="fsaStateDisplayManager">
    <!-- attributes: graph, model -->
    
    <method name="setStates" args="states">
      for (var i in subviews)
        subviews[i].setVisible(false);
      var tn = graph.nodes;
      this.stateviews = [];
      this.hidden = [];
      for (var i in states) {
        var s = states[i];
        var sv = new stateview(this, {});
        sv.graph = graph;
        sv.setState(s);
	stateviews.push(sv);
      }
      this.pos = 0;
    </method>
    
    <method name="hideOldStates"><![CDATA[
      // remove views to the left of the cursor, so we don't ever have
      // to test whether the item at the cursor is null
      for (var i = 1; i < stateviews.length; i++)
        for (var j = 0; j < i; j++) {
          var sv = stateviews[j];
          if (sv == null) continue;
          if (sv.state == null || stateviews[i].state == sv.state) {
            stateviews[j] = null;
            sv.setVisible(false);
            hidden.push(sv);
          }
        }
      Array.compact(stateviews);
    ]]></method>
    
    <method name="advanceStates" args="symbol, duration"><![CDATA[
      if (arguments.length < 2) duration = 0;
      this.pos++;
      
      hideOldStates();
      
      // now, split and move the states
      newviews = []; // so they don't interfere with the iterator
      for (var i in this.stateviews) {
        var sv = this.stateviews[i];
        var s0 = sv.state;
        var transitions = [];
        for (var j in model.transitions) {
          var t = model.transitions[j];
          if (t.start == s0 && t.edge.indexOf(symbol) >= 0)
            transitions.push(t);
        }
        if (transitions.length) {
          for (var j = 1; j < transitions.length; j++) {
            var svn = sv.clone()
            svn.setState(transitions[j].end, duration);
            newviews.push(svn);
          }
          // do this last, so we can read the state out of
          // it when we make the clones
          sv.setState(transitions[0].end, duration);
        } else
          sv.setState(null, duration);
      }
      this.stateviews = this.stateviews.concat(newviews);
    ]]></method>
    
    <method name="rewindStates">
      var pos = --this.pos;
      hideOldStates();
      
      for (var i in stateviews)
        stateviews[i].rewind()
      for (var i in hidden) {
        var sv = hidden[i];
        if (sv.rewindTo(pos))
          stateviews.push(sv);
      }
    </method>
  </class>
  
  <script><![CDATA[
    function Graph(nodes, edges) {
      this.nodes = nodes;
      this.edges = edges;
    };
    Graph.prototype.makeEdgePath = function (edge) {
      var path = new Path;
      var points = edge.pos;
      var n0 = this.nodes[edge.start];
      var n1 = this.nodes[edge.stop];
      path.addLine({x: n0.x, y: n0.y}, points[0]);
      for (var i = 0; i+1 < points.length; i += 3)
        path.addCubic([points[i], points[i+1], points[i+2], points[i+3]]);
      path.addLine(points[points.length-1], {x: n1.x, y: n1.y});
      return path;
    }
    Graph.prototype.findEdge = function (s0, s1) {
      var edges = this.edges;
      for (var i in edges)
        if (edges[i].start == s0 && edges[i].stop == s1)
          return edges[i];
      return null;
    }
  ]]></script>
</library>
